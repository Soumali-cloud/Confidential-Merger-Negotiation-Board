// Enhanced Confidential Merger Negotiation Board
// With Cryptographic Commitments & Advanced Proof Statements
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0

pragma language_version >= 0.20;

import CompactStandardLibrary;

// ============================================
// PUBLIC STATE - ON-CHAIN RECORDS
// ============================================

// Track active deals and qualifications
export ledger active_deals: Counter;
export ledger qualified_companies: Counter;
export ledger total_proofs_submitted: Counter;

// ============================================
// COMMITMENT & PROOF STATE
// ============================================

// Witness: Company's confidential financial data
witness private_revenue: field;
witness private_assets: field;
witness private_liabilities: field;
witness company_secret_nonce: field;

// Public inputs: Deal parameters and thresholds
public_input deal_id: field;
public_input min_revenue_threshold: field;
public_input min_asset_threshold: field;
public_input min_net_worth_threshold: field;
public_input max_debt_ratio_threshold: field;  // Assets / Liabilities ratio

// Public input: Commitment hash (binds witness to proof)
public_input commitment_hash: field;

// ============================================
// ADVANCED PROOF CIRCUITS
// ============================================

// Primary circuit: Generate commitment and prove qualification
export circuit generate_commitment(): [field] {
    // 1. COMMITMENT GENERATION
    // Hash(revenue || assets || liabilities || nonce) creates cryptographic binding
    // This prevents witness manipulation after proof generation
    let computed_commitment = poseidon([
        private_revenue,
        private_assets,
        private_liabilities,
        company_secret_nonce
    ]);
    
    // Prove commitment matches
    assert(computed_commitment == commitment_hash);
    
    // 2. FINANCIAL QUALIFICATION PROOFS
    // Revenue threshold check
    assert(private_revenue >= min_revenue_threshold);
    
    // Asset threshold check
    assert(private_assets >= min_asset_threshold);
    
    // Solvency check: Assets > Liabilities
    assert(private_assets > private_liabilities);
    
    // 3. ADVANCED CONDITIONS
    // Net worth (Assets - Liabilities) must meet threshold
    let net_worth = private_assets - private_liabilities;
    assert(net_worth >= min_net_worth_threshold);
    
    // Debt ratio check: Assets / Liabilities must not exceed max_debt_ratio
    // Since we are in field arithmetic, we check: Assets >= Liabilities * max_debt_ratio
    // This is equivalent to Assets/Liabilities >= max_debt_ratio
    let scaled_max_debt = private_liabilities * max_debt_ratio_threshold;
    assert(private_assets >= scaled_max_debt);
    
    // 4. LOG PROOF SUBMISSION
    total_proofs_submitted.increment(1);
    qualified_companies.increment(1);
    active_deals.increment(1);
    
    // Return commitment hash as proof of qualification
    return [computed_commitment];
}

// Secondary circuit: Verify deal qualification without revealing witness
export circuit verify_qualification(): [] {
    // Verify all conditions using public commitment (already verified on-chain)
    
    // Solvency: Assets > Liabilities
    assert(private_assets > private_liabilities);
    
    // Revenue qualification
    assert(private_revenue >= min_revenue_threshold);
    
    // Asset qualification
    assert(private_assets >= min_asset_threshold);
    
    // Net worth qualification
    let net_worth = private_assets - private_liabilities;
    assert(net_worth >= min_net_worth_threshold);
    
    // Debt ratio qualification
    let scaled_max_debt = private_liabilities * max_debt_ratio_threshold;
    assert(private_assets >= scaled_max_debt);
}

// Query circuit: Get qualified count without revealing witness
export circuit get_qualified_count(): field {
    return qualified_companies.value();
}

// Query circuit: Get total proofs submitted
export circuit get_proof_statistics(): field {
    return total_proofs_submitted.value();
}

// Query circuit: Get active deals count
export circuit get_active_deals_count(): field {
    return active_deals.value();
}
